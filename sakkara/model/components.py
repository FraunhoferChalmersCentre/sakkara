import operator
from abc import ABC
from typing import Any, Set, Callable, Dict, Union, Optional, Tuple

import aesara
import aesara.tensor as at
import numpy as np
import pymc as pm
import numpy.typing as npt

from sakkara.model.base import ModelComponent, FixedComponent, wrap
from sakkara.model.composite import CompositeComponent
from sakkara.relation.node import NodePair
from sakkara.relation.groupset import GroupSet


class OperationBaseComponent(ModelComponent, ABC):
    """
    Base class for all operable components
    """

    def __init__(self, name: Optional[str]):
        super().__init__()
        self.name = name

    def get_name(self) -> Optional[str]:
        return self.name

    def set_name(self, name: str) -> None:
        self.name = name

    def __add__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.add)

    def __sub__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.sub)

    def __mul__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.mul)

    def __rmul__(self, other: Any) -> ModelComponent:
        return CompositeComponent(wrap(other), self, operator.mul)

    def __truediv__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.truediv)

    def __rtruediv__(self, other: Any):
        return CompositeComponent(wrap(other), self, operator.truediv)

    def __neg__(self):
        return CompositeComponent(FixedComponent(0), self, operator.sub)


class HierarchicalComponent(OperationBaseComponent, ABC):
    """
    Base class for a component that can be built with underlying components
    """

    def __init__(self, name: str, columns: Union[str, Tuple[str, ...]], components: Dict[Any, ModelComponent]):
        super().__init__(name)
        self.columns = (columns,) if isinstance(columns, str) else columns
        self.components = components

    def __getitem__(self, item: Any):
        return self.components[item]

    def clear(self):
        self.variable = None
        self.node = None
        for c in self.components.values():
            c.clear()

    def prebuild(self, groupset: GroupSet) -> None:
        for param_name, component in self.components.items():
            if component.get_name() is None:
                component.set_name(f'{param_name}_{self.get_name()}')
            if component.variable is None:
                component.build(groupset)

    def retrieve_columns(self) -> Set[str]:
        columns = set()
        for k, v in self.components.items():
            parent_groups = v.retrieve_columns()
            columns = columns.union(parent_groups)
        if self.columns is not None:
            columns = columns.union(self.columns)

        return columns

    def dims(self):
        if self.node.get_members().shape == (1,):
            return None
        dims = tuple(map(str, self.node.representation()))
        if 1 == len(dims):
            return dims[0]
        return dims


class PymcGenerateable(HierarchicalComponent):
    """
    Class for components whose variable is generated by a PyMC distribution
    """

    def __init__(self, generator: Callable, name: str, columns: Union[str, Tuple[str, ...]],
                 components: Dict[Any, ModelComponent]):
        super().__init__(name, columns, components)
        self.generator = generator

    def build_node(self, groupset: GroupSet) -> None:
        self.node = groupset[self.columns[0]]
        for column in self.columns[1:]:
            self.node = NodePair(groupset[column], self.node).reduced_repr()

        for component in self.components.values():
            self.node = NodePair(self.node, component.node).reduced_repr()

    def build_variable(self) -> None:
        built_components = {}

        for key, component in self.components.items():

            if self.node.representation() == component.node.representation() or component.node.get_members().shape == (
                    1,):
                built_components[key] = component.variable
            else:
                built_components[key] = component.variable[self.node.map_to(component.node)]

        self.variable = self.generator(self.name, **built_components, dims=self.dims())


class Deterministic(PymcGenerateable, ABC):
    """
    Class for deterministic values of a variable
    """

    def __init__(self, value: Union[float, npt.NDArray[float]], name: str = None,
                 columns: Union[str, Tuple[str]] = 'global'):
        super().__init__(pm.Deterministic, name, columns, {'var': FixedComponent(aesara.shared(value))})


class Distribution(PymcGenerateable, ABC):
    """
    Class for variable that can be generated using PyMC
    """

    def __init__(self, generator: Callable, name: str = None, columns: Union[str, Tuple[str, ...]] = 'global',
                 **kwargs):
        """

        Parameters
        ----------
        generator: Function for generating the distribution, e.g., pymc.Normal
        name: Name of the variable
        columns: Column of the group of the variable.
        kwargs: Parameters to the distribution.
        """
        components = {k: v if isinstance(v, ModelComponent) else FixedComponent(v) for k, v in kwargs.items()}
        super().__init__(generator, name, columns, components)


class Concat(HierarchicalComponent, ABC):
    """
    Class for specifying components for each member of a group individually
    """

    def __init__(self, columns: Union[str, Tuple[str, ...]], name: str = None, components: Dict[Any, Any] = None):
        """

        Parameters
        ----------
        components: Dictionary with key indicating member and value its corresponding variable
        columns: The column of the group in the dataframe.
        name: Name of the concatenated variable.
        """
        if components is None:
            components = {}
        else:
            components = {k: v if isinstance(v, ModelComponent) else Deterministic(v) for k, v in
                          components.items()}
        super().__init__(name, columns, components)
        self.column_node = None
        self.components_node = None

    def clear(self):
        super(Concat, self).clear()
        self.column_node = None
        self.components_node = None

    def add(self, key: Any, component: Union[float, npt.NDArray, ModelComponent]):
        if not isinstance(component, ModelComponent):
            component = Deterministic(component)
        self.components[key] = component

    def build_node(self, groupset: GroupSet) -> None:
        self.column_node = groupset[self.columns[0]]
        for column in self.columns[1:]:
            self.column_node = NodePair(groupset[column], self.column_node).reduced_repr()

        self.components_node = next(iter(self.components.values())).node
        for component in self.components.values():
            self.components_node = NodePair(self.components_node, component.node).reduced_repr()

        self.node = NodePair(self.column_node, self.components_node).reduced_repr()

    def build_variable(self) -> None:
        built_components = {}

        for key, component in self.components.items():
            if not isinstance(key, tuple):
                member_key = key,
            else:
                member_key = key

            if self.components_node.get_members().shape == (1,):
                built_components[member_key] = component.variable
            else:
                member_key_match = np.vectorize(lambda node: node.get_key() == member_key)
                raveled_member_index = np.argwhere(member_key_match(self.column_node.get_members().ravel()))

                if len(raveled_member_index) == 0:
                    raise ValueError(f'Member for {member_key} not found among the nodes created from dataframe')

                raveled_member_index = raveled_member_index.squeeze()

                node_to_col = self.node.map_to(self.column_node)
                raveled_node_to_col = np.ravel_multi_index(tuple(map(np.ravel, node_to_col)),
                                                           self.column_node.get_members().shape)

                node_to_comp = self.node.map_to(self.components_node)
                raveled_node_to_comp = np.ravel_multi_index(tuple(map(np.ravel, node_to_comp)),
                                                            self.components_node.get_members().shape)

                raveled_comp_members = raveled_node_to_comp[raveled_node_to_col == raveled_member_index]
                comp_members = np.unravel_index(raveled_comp_members, self.components_node.get_members().shape)

                if component.node.representation() != self.components_node.representation():
                    if component.node.get_members().shape == (1,):
                        comp_variable = at.stack(
                            [component.variable] * len(self.components_node.get_members().ravel())
                        ).reshape(self.components_node.get_members().shape)
                    else:
                        joint_comp_to_this_comp = self.components_node.map_to(component.node)
                        comp_variable = component.variable[joint_comp_to_this_comp]
                else:
                    comp_variable = component.variable

                built_components[member_key] = comp_variable[comp_members]

        undefined_members = list(
            m for m in self.column_node.get_members() if m.get_key() not in list(built_components.keys()))
        if 0 < len(undefined_members):
            raise KeyError('Members ' + ','.join(map(str, undefined_members)) + ' of ' + str(
                self.column_node) + ' must be defined to build concat variable')

        at_tensor = at.stack([built_components[m.get_key()] for m in self.column_node.get_members().ravel()])
        self.variable = pm.Deterministic(name=self.name,
                                         var=at_tensor.reshape(self.node.get_members().shape),
                                         dims=self.dims())
