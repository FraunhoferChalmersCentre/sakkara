import operator
from abc import ABC
from typing import Any, Set, Callable, Dict, Union, Optional

import aesara
import aesara.tensor as at
import pymc as pm
import numpy.typing as npt

from sakkara.model.base import ModelComponent, FixedComponent, wrap
from sakkara.model.composite import CompositeComponent
from sakkara.relation.node import NodePair
from sakkara.relation.groupset import GroupSet


class OperationBaseComponent(ModelComponent, ABC):
    """
    Base class for all operable components
    """

    def __init__(self, name: Optional[str]):
        super().__init__()
        self.name = name

    def get_name(self) -> Optional[str]:
        return self.name

    def set_name(self, name: str) -> None:
        self.name = name

    def __add__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.add)

    def __sub__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.sub)

    def __mul__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.mul)

    def __rmul__(self, other: Any) -> ModelComponent:
        return CompositeComponent(wrap(other), self, operator.mul)

    def __truediv__(self, other: Any) -> ModelComponent:
        return CompositeComponent(self, wrap(other), operator.truediv)

    def __rtruediv__(self, other: Any):
        return CompositeComponent(wrap(other), self, operator.truediv)

    def __neg__(self):
        return CompositeComponent(FixedComponent(0), self, operator.sub)


class HierarchicalComponent(OperationBaseComponent, ABC):
    """
    Base class for a component that can be built with underlying components
    """

    def __init__(self, name: str, column: str, components: Dict[Any, ModelComponent]):
        super().__init__(name)
        self.column = column
        self.components = components

    def __getitem__(self, item: Any):
        return self.components[item]

    def clear(self):
        self.variable = None
        self.node = None
        for c in self.components.values():
            c.clear()

    def prebuild(self, groupset: GroupSet) -> None:
        for param_name, component in self.components.items():
            if component.get_name() is None:
                component.set_name(f'{param_name}_{self.get_name()}')
            if component.variable is None:
                component.build(groupset)

    def retrieve_columns(self) -> Set[str]:
        columns = set()
        for k, v in self.components.items():
            parent_groups = v.retrieve_columns()
            columns = columns.union(parent_groups)
        if self.column is not None:
            columns.add(self.column)

        return columns


class PymcGenerateable(HierarchicalComponent):
    """
    Class for components whose variable is generated by a PyMC distribution
    """

    def __init__(self, generator: Callable, name: str, column: str, components: Dict[Any, ModelComponent]):
        super().__init__(name, column, components)
        self.generator = generator

    def build_node(self, groupset: GroupSet) -> None:
        self.node = groupset[self.column]

    def build_variable(self) -> None:
        built_components = {}

        for key, component in self.components.items():

            if self.node.representation() == component.node.representation() or len(component.node) == 1:
                built_components[key] = component.variable
            else:
                built_components[key] = component.variable[self.node.map_to(component.node)]

        if self.column is not None and 1 < len(self.node):
            dims = self.column
        else:
            dims = None

        self.variable = self.generator(self.name, **built_components, dims=dims)


class Deterministic(PymcGenerateable, ABC):
    """
    Class for deterministic values of a variable
    """

    def __init__(self, value: Union[float, npt.NDArray[float]], name: str = None, column: str = 'global'):
        super().__init__(pm.Deterministic, name, column, {'var': FixedComponent(aesara.shared(value))})


class Distribution(PymcGenerateable, ABC):
    """
    Class for variable that can be generated using PyMC
    """

    def __init__(self, generator: Callable, name: str = None, column: str = 'global', **kwargs):
        """

        Parameters
        ----------
        generator: Function for generating the distribution, e.g., pymc.Normal
        name: Name of the variable
        column: Column of the group of the variable.
        kwargs: Parameters to the distribution.
        """
        components = {k: v if isinstance(v, ModelComponent) else FixedComponent(v) for k, v in kwargs.items()}
        super().__init__(generator, name, column, components)


class Concat(HierarchicalComponent, ABC):
    """
    Class for specifying components for each member of a group individually
    """

    def __init__(self, column: str, name: str = None, components: Dict[Any, Any] = None):
        """

        Parameters
        ----------
        components: Dictionary with key indicating member and value its corresponding variable
        column: The column of the group in the dataframe.
        name: Name of the concatenated variable.
        """
        if components is None:
            components = {}
        else:
            components = {k: v if isinstance(v, ModelComponent) else Deterministic(v) for k, v in
                          components.items()}
        super().__init__(name, column, components)
        self.column_node = None
        self.components_node = None

    def clear(self):
        super(Concat, self).clear()
        self.column_node = None
        self.components_node = None

    def add(self, key: Any, component: Union[float, npt.NDArray, ModelComponent]):
        if not isinstance(component, ModelComponent):
            component = Deterministic(component)
        self.components[key] = component

    def build_node(self, groupset: GroupSet) -> None:
        self.column_node = groupset[self.column]

        self.components_node = next(iter(self.components.values())).node
        for component in self.components.values():
            self.components_node = NodePair(self.components_node, component.node).reduced_repr()

        self.node = NodePair(self.column_node, self.components_node).reduced_repr()

    def build_variable(self) -> None:
        built_components = {}

        for key, component in self.components.items():
            member_index = next(i for i, m in enumerate(self.column_node.get_members()) if m.get_key() == key)
            node_to_column = self.node.map_to(self.column_node)
            node_to_component = self.node.map_to(self.components_node)
            components = node_to_component[node_to_column == member_index]

            if len(component.node) == 1:
                built_components[key] = at.stack([component.variable.flatten()] * len(components))
            else:
                mapping = self.components_node.map_to(component.node)[components]
                if mapping is None:
                    built_components[key] = component.variable
                else:
                    built_components[key] = component.variable[mapping]

        undefined_members = list(
            m for m in self.column_node.get_members() if m.get_key() not in list(built_components.keys()))
        if 0 < len(undefined_members):
            raise KeyError('Members ' + ','.join(map(str, undefined_members)) + ' of ' + str(
                self.column_node) + ' must be defined to build concat variable')

        self.variable = at.concatenate([built_components[m.get_key()].flatten() for m in self.column_node.get_members()])
